---
layout: post
comments: false 
title: "Pytorch中回归指标的计算方法" 
date: 2022-3-22
tags: daily
---

实现Pytorch环境下对Mean Absolute Error, Mean Relative Error和Pearson Correlation等评价指标的计算和验证。

<!--more-->

最近在做RouteNet模型从Tensorflow到Pytorch的复现工作，发现Tensorflow中定义的一些评价API在Pytorch中并没有，就通过调用其他工具包和自己写轮子的方法进行了实现。

尤其是`tf.metrics.mean_relative_error`计算MRE，在网上的资料很少，仅有Pytorch-ignite包提供了计算方法和公式，但为了算一个指标专门装一个包也太不优雅了，看计算公式比较简单，于是干脆自己写了一个计算方法，并通过测试样例验证与tensorflow的结果是否相同。

# Mean Relative Error

在tensorflow的[官方API文档](https://tensorflow.google.cn/api_docs/python/tf/compat/v1/metrics/mean_relative_error)中对该指标的定义为：

> The mean_relative_error function creates two local variables, total and count that are used to compute the mean relative absolute error.

所以我们可以认为，tf中的mean relative error其实等效为mean relative absolute error。

在Google中搜索mean relative absolute error pytorch后第一个结果告诉我，Pytorch-ignite包中实现了这个评价的计算，并给出了[计算公式](https://pytorch.org/ignite/generated/ignite.contrib.metrics.regression.MeanAbsoluteRelativeError.html#ignite.contrib.metrics.regression.MeanAbsoluteRelativeError)。但这个包对于计算封装的过于繁琐，就算安装后也难以直接调用，且为了一个简单的计算专门安装一个包也太不优雅了，于是决定根据公式自己实现一下。

此外在stack overflow冲浪的时候还看到一个R语言实现的RAE计算公式，那再套一个mean不就也是MRAE了吗。一时竟不知道哪个才是对的，只好写一个测试样例，分别计算一下，并和tf的做对比。其中需要注意三者在计算的过程中都使用float32类型，float32与float64在最终结果上会有差异，但不能算作计算不正确。

```python
import numpy as np
import tensorflow as tf
import scipy.stats as measures

y_pred = np.array([2, 2, 3, 4, 5, 5, 4, 2], dtype=np.float32)
y_true = np.array([1, 2, 3, 4, 5, 6, 7, 8], dtype=np.float32)

## R
val1 = np.mean(abs(y_true - y_pred) / abs(y_true - np.mean(y_true)))
print("val1: \t{}".format(val1))

## ignite
val2 = np.mean(abs(y_true - y_pred) / abs(y_true))
print("val2: \t{}".format(val2))

## Tensorflow
logits = tf.placeholder(tf.float32, [8])
labels = tf.to_float(tf.Variable(y_true))

acc, acc_op = tf.metrics.mean_relative_error(labels, logits, labels)

sess = tf.Session()
sess.run(tf.local_variables_initializer())
sess.run(tf.global_variables_initializer())
sess.run(acc, {logits:y_pred})
sess.run(acc_op, {logits:y_pred})

print("val3: \t{}".format(sess.run(acc,{logits:y_pred})))
```

最终计算结果为
```shell
val1:   0.4833333492279053
val2:   0.293154776096344
val3:   0.293154776096344
```

结论，ignite的计算公式是对的，按照val2的计算过程来写就能实现`tf.metrics.mean_relative_error`

PS：这个测试代码也可以用来测试其他tf的API结果，很实用。